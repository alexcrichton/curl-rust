<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A multi handle for initiating multiple connections simultaneously."><title>Multi in curl::multi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="curl" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../curl/index.html">curl</a><span class="version">0.4.49</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Multi</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.action" title="action">action</a></li><li><a href="#method.add" title="add">add</a></li><li><a href="#method.add2" title="add2">add2</a></li><li><a href="#method.assign" title="assign">assign</a></li><li><a href="#method.fdset2" title="fdset2">fdset2</a></li><li><a href="#method.get_timeout" title="get_timeout">get_timeout</a></li><li><a href="#method.messages" title="messages">messages</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.perform" title="perform">perform</a></li><li><a href="#method.pipelining" title="pipelining">pipelining</a></li><li><a href="#method.poll" title="poll">poll</a></li><li><a href="#method.raw" title="raw">raw</a></li><li><a href="#method.remove" title="remove">remove</a></li><li><a href="#method.remove2" title="remove2">remove2</a></li><li><a href="#method.set_max_concurrent_streams" title="set_max_concurrent_streams">set_max_concurrent_streams</a></li><li><a href="#method.set_max_connects" title="set_max_connects">set_max_connects</a></li><li><a href="#method.set_max_host_connections" title="set_max_host_connections">set_max_host_connections</a></li><li><a href="#method.set_max_total_connections" title="set_max_total_connections">set_max_total_connections</a></li><li><a href="#method.set_pipeline_length" title="set_pipeline_length">set_pipeline_length</a></li><li><a href="#method.socket_function" title="socket_function">socket_function</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.timer_function" title="timer_function">timer_function</a></li><li><a href="#method.wait" title="wait">wait</a></li><li><a href="#method.waker" title="waker">waker</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Multi" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Multi" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Multi" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-Multi" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Multi" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Multi" title="Freeze">Freeze</a></li><li><a href="#impl-Unpin-for-Multi" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In curl::<wbr>multi</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">curl</a>::<wbr><a href="index.html">multi</a></div><h1>Struct <span class="struct">Multi</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/curl/multi.rs.html#31-34">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Multi { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A multi handle for initiating multiple connections simultaneously.</p>
<p>This structure corresponds to <code>CURLM</code> in libcurl and provides the ability to
have multiple transfers in flight simultaneously. This handle is then used
to manage each transfer. The main purpose of a <code>CURLM</code> is for the
<em>application</em> to drive the I/O rather than libcurl itself doing all the
blocking. Methods like <code>action</code> allow the application to inform libcurl of
when events have happened.</p>
<p>Lots more documentation can be found on the libcurl <a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html">multi tutorial</a> where
the APIs correspond pretty closely with this crate.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Multi" class="impl"><a class="src rightside" href="../../src/curl/multi.rs.html#125-816">Source</a><a href="#impl-Multi" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#128-141">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h4></section></summary><div class="docblock"><p>Creates a new multi session through which multiple HTTP transfers can be
initiated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.socket_function" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#157-162">Source</a><h4 class="code-header">pub fn <a href="#method.socket_function" class="fn">socket_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="type" href="type.Socket.html" title="type curl::multi::Socket">Socket</a>, <a class="struct" href="struct.SocketEvents.html" title="struct curl::multi::SocketEvents">SocketEvents</a>, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) + <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Set the callback informed about what to wait for</p>
<p>When the <code>action</code> function runs, it informs the application about
updates in the socket (file descriptor) status by doing none, one, or
multiple calls to the socket callback. The callback gets status updates
with changes since the previous time the callback was called. See
<code>action</code> for more details on how the callback is used and should work.</p>
<p>The <code>SocketEvents</code> parameter informs the callback on the status of the
given socket, and the methods on that type can be used to learn about
what’s going on with the socket.</p>
<p>The third <code>usize</code> parameter is a custom value set by the <code>assign</code> method
below.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assign" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#226-235">Source</a><h4 class="code-header">pub fn <a href="#method.assign" class="fn">assign</a>(&amp;self, socket: <a class="type" href="type.Socket.html" title="type curl::multi::Socket">Socket</a>, token: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Set data to associate with an internal socket</p>
<p>This function creates an association in the multi handle between the
given socket and a private token of the application. This is designed
for <code>action</code> uses.</p>
<p>When set, the token will be passed to all future socket callbacks for
the specified socket.</p>
<p>If the given socket isn’t already in use by libcurl, this function will
return an error.</p>
<p>libcurl only keeps one single token associated with a socket, so
calling this function several times for the same socket will make the
last set token get used.</p>
<p>The idea here being that this association (socket to token) is something
that just about every application that uses this API will need and then
libcurl can just as well do it since it already has an internal hash
table lookup for this.</p>
<h5 id="typical-usage"><a class="doc-anchor" href="#typical-usage">§</a>Typical Usage</h5>
<p>In a typical application you allocate a struct or at least use some kind
of semi-dynamic data for each socket that we must wait for action on
when using the <code>action</code> approach.</p>
<p>When our socket-callback gets called by libcurl and we get to know about
yet another socket to wait for, we can use <code>assign</code> to point out the
particular data so that when we get updates about this same socket
again, we don’t have to find the struct associated with this socket by
ourselves.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timer_function" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#256-261">Source</a><h4 class="code-header">pub fn <a href="#method.timer_function" class="fn">timer_function</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Set callback to receive timeout values</p>
<p>Certain features, such as timeouts and retries, require you to call
libcurl even when there is no activity on the file descriptors.</p>
<p>Your callback function should install a non-repeating timer with the
interval specified. Each time that timer fires, call either <code>action</code> or
<code>perform</code>, depending on which interface you use.</p>
<p>A timeout value of <code>None</code> means you should delete your timer.</p>
<p>A timeout value of 0 means you should call <code>action</code> or <code>perform</code> (once)
as soon as possible.</p>
<p>This callback will only be called when the timeout changes.</p>
<p>The timer callback should return <code>true</code> on success, and <code>false</code> on
error. This callback can be used instead of, or in addition to,
<code>get_timeout</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pipelining" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#311-319">Source</a><h4 class="code-header">pub fn <a href="#method.pipelining" class="fn">pipelining</a>(
    &amp;mut self,
    http_1: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
    multiplex: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Enable or disable HTTP pipelining and multiplexing.</p>
<p>When http_1 is true, enable HTTP/1.1 pipelining, which means that if
you add a second request that can use an already existing connection,
the second request will be “piped” on the same connection rather than
being executed in parallel.</p>
<p>When multiplex is true, enable HTTP/2 multiplexing, which means that
follow-up requests can re-use an existing connection and send the new
request multiplexed over that at the same time as other transfers are
already using that single connection.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_host_connections" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#329-331">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_host_connections" class="fn">set_max_host_connections</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the max number of connections to a single host.</p>
<p>Pass a long to indicate the max number of simultaneously open connections
to a single host (a host being the same as a host name + port number pair).
For each new session to a host, libcurl will open up a new connection up to the
limit set by the provided value. When the limit is reached, the sessions will
be pending until a connection becomes available. If pipelining is enabled,
libcurl will try to pipeline if the host is capable of it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_total_connections" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#341-343">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_total_connections" class="fn">set_max_total_connections</a>(
    &amp;mut self,
    val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the max simultaneously open connections.</p>
<p>The set number will be used as the maximum number of simultaneously open
connections in total using this multi handle. For each new session,
libcurl will open a new connection up to the limit set by the provided
value. When the limit is reached, the sessions will be pending until
there are available connections. If pipelining is enabled, libcurl will
try to pipeline or use multiplexing if the host is capable of it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_connects" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#360-362">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_connects" class="fn">set_max_connects</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Set size of connection cache.</p>
<p>The set number will be used as the maximum amount of simultaneously open
connections that libcurl may keep in its connection cache after
completed use. By default libcurl will enlarge the size for each added
easy handle to make it fit 4 times the number of added easy handles.</p>
<p>By setting this option, you can prevent the cache size from growing
beyond the limit set by you.</p>
<p>When the cache is full, curl closes the oldest one in the cache to
prevent the number of open connections from increasing.</p>
<p>See <a href="#method.set_max_total_connections"><code>set_max_total_connections</code></a> for
limiting the number of active connections.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_pipeline_length" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#369-371">Source</a><h4 class="code-header">pub fn <a href="#method.set_pipeline_length" class="fn">set_pipeline_length</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the pipeline length.</p>
<p>This sets the max number that will be used as the maximum amount of
outstanding requests in an HTTP/1.1 pipelined connection. This option
is only used for HTTP/1.1 pipelining, and not HTTP/2 multiplexing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_concurrent_streams" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#378-380">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_concurrent_streams" class="fn">set_max_concurrent_streams</a>(
    &amp;mut self,
    val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the number of max concurrent streams for http2.</p>
<p>This sets the max number will be used as the maximum number of
concurrent streams for a connections that libcurl should support on
connections done using HTTP/2. Defaults to 100.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#413-429">Source</a><h4 class="code-header">pub fn <a href="#method.add" class="fn">add</a>(&amp;self, easy: <a class="struct" href="../easy/struct.Easy.html" title="struct curl::easy::Easy">Easy</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.EasyHandle.html" title="struct curl::multi::EasyHandle">EasyHandle</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Add an easy handle to a multi session</p>
<p>Adds a standard easy handle to the multi stack. This function call will
make this multi handle control the specified easy handle.</p>
<p>When an easy interface is added to a multi handle, it will use a shared
connection cache owned by the multi handle. Removing and adding new easy
handles will not affect the pool of connections or the ability to do
connection re-use.</p>
<p>If you have <code>timer_function</code> set in the multi handle (and you really
should if you’re working event-based with <code>action</code> and friends), that
callback will be called from within this function to ask for an updated
timer so that your main event loop will get the activity on this handle
to get started.</p>
<p>The easy handle will remain added to the multi handle until you remove
it again with <code>remove</code> on the returned handle - even when a transfer
with that specific easy handle is completed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add2" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#432-444">Source</a><h4 class="code-header">pub fn <a href="#method.add2" class="fn">add2</a>&lt;H&gt;(&amp;self, easy: <a class="struct" href="../easy/struct.Easy2.html" title="struct curl::easy::Easy2">Easy2</a>&lt;H&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Easy2Handle.html" title="struct curl::multi::Easy2Handle">Easy2Handle</a>&lt;H&gt;, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Same as <code>add</code>, but works with the <code>Easy2</code> type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#457-460">Source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>(&amp;self, easy: <a class="struct" href="struct.EasyHandle.html" title="struct curl::multi::EasyHandle">EasyHandle</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../easy/struct.Easy.html" title="struct curl::easy::Easy">Easy</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Remove an easy handle from this multi session</p>
<p>Removes the easy handle from this multi handle. This will make the
returned easy handle be removed from this multi handle’s control.</p>
<p>When the easy handle has been removed from a multi stack, it is again
perfectly legal to invoke <code>perform</code> on it.</p>
<p>Removing an easy handle while being used is perfectly legal and will
effectively halt the transfer in progress involving that easy handle.
All other easy handles and transfers will remain unaffected.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove2" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#463-466">Source</a><h4 class="code-header">pub fn <a href="#method.remove2" class="fn">remove2</a>&lt;H&gt;(&amp;self, easy: <a class="struct" href="struct.Easy2Handle.html" title="struct curl::multi::Easy2Handle">Easy2Handle</a>&lt;H&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../easy/struct.Easy2.html" title="struct curl::easy::Easy2">Easy2</a>&lt;H&gt;, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Same as <code>remove</code>, but for <code>Easy2Handle</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.messages" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#474-479">Source</a><h4 class="code-header">pub fn <a href="#method.messages" class="fn">messages</a>&lt;F&gt;(&amp;self, f: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="struct" href="struct.Message.html" title="struct curl::multi::Message">Message</a>&lt;'_&gt;),</div></h4></section></summary><div class="docblock"><p>Read multi stack informationals</p>
<p>Ask the multi handle if there are any messages/informationals from the
individual transfers. Messages may include informationals such as an
error code from the transfer or just the fact that a transfer is
completed. More details on these should be written down as well.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.action" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#515-526">Source</a><h4 class="code-header">pub fn <a href="#method.action" class="fn">action</a>(&amp;self, socket: <a class="type" href="type.Socket.html" title="type curl::multi::Socket">Socket</a>, events: &amp;<a class="struct" href="struct.Events.html" title="struct curl::multi::Events">Events</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Inform of reads/writes available data given an action</p>
<p>When the application has detected action on a socket handled by libcurl,
it should call this function with the sockfd argument set to
the socket with the action. When the events on a socket are known, they
can be passed <code>events</code>. When the events on a socket are unknown, pass
<code>Events::new()</code> instead, and libcurl will test the descriptor
internally.</p>
<p>The returned integer will contain the number of running easy handles
within the multi handle. When this number reaches zero, all transfers
are complete/done. When you call <code>action</code> on a specific socket and the
counter decreases by one, it DOES NOT necessarily mean that this exact
socket/transfer is the one that completed. Use <code>messages</code> to figure out
which easy handle that completed.</p>
<p>The <code>action</code> function informs the application about updates in the
socket (file descriptor) status by doing none, one, or multiple calls to
the socket callback function set with the <code>socket_function</code> method. They
update the status with changes since the previous time the callback was
called.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#543-554">Source</a><h4 class="code-header">pub fn <a href="#method.timeout" class="fn">timeout</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Inform libcurl that a timeout has expired and sockets should be tested.</p>
<p>The returned integer will contain the number of running easy handles
within the multi handle. When this number reaches zero, all transfers
are complete/done. When you call <code>action</code> on a specific socket and the
counter decreases by one, it DOES NOT necessarily mean that this exact
socket/transfer is the one that completed. Use <code>messages</code> to figure out
which easy handle that completed.</p>
<p>Get the timeout time by calling the <code>timer_function</code> method. Your
application will then get called with information on how long to wait
for socket actions at most before doing the timeout action: call the
<code>timeout</code> method. You can also use the <code>get_timeout</code> function to
poll the value at any given time, but for an event-based system using
the callback is far better than relying on polling the timeout value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_timeout" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#573-583">Source</a><h4 class="code-header">pub fn <a href="#method.get_timeout" class="fn">get_timeout</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Get how long to wait for action before proceeding</p>
<p>An application using the libcurl multi interface should call
<code>get_timeout</code> to figure out how long it should wait for socket actions -
at most - before proceeding.</p>
<p>Proceeding means either doing the socket-style timeout action: call the
<code>timeout</code> function, or call <code>perform</code> if you’re using the simpler and
older multi interface approach.</p>
<p>The timeout value returned is the duration at this very moment. If 0, it
means you should proceed immediately without waiting for anything. If it
returns <code>None</code>, there’s no timeout at all set.</p>
<p>Note: if libcurl returns a <code>None</code> timeout here, it just means that
libcurl currently has no stored timeout value. You must not wait too
long (more than a few seconds perhaps) before you call <code>perform</code> again.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#610-623">Source</a><h4 class="code-header">pub fn <a href="#method.wait" class="fn">wait</a>(
    &amp;self,
    waitfds: &amp;mut [<a class="struct" href="struct.WaitFd.html" title="struct curl::multi::WaitFd">WaitFd</a>],
    timeout: <a class="struct" href="https://doc.rust-lang.org/1.89.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Block until activity is detected or a timeout passes.</p>
<p>The timeout is used in millisecond-precision. Large durations are
clamped at the maximum value curl accepts.</p>
<p>The returned integer will contain the number of internal file
descriptors on which interesting events occured.</p>
<p>This function is a simpler alternative to using <code>fdset()</code> and <code>select()</code>
and does not suffer from file descriptor limits.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>curl::multi::Multi;
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span>m = Multi::new();

<span class="comment">// Add some Easy handles...

</span><span class="kw">while </span>m.perform().unwrap() &gt; <span class="number">0 </span>{
    m.wait(<span class="kw-2">&amp;mut </span>[], Duration::from_secs(<span class="number">1</span>)).unwrap();
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#671-684">Source</a><h4 class="code-header">pub fn <a href="#method.poll" class="fn">poll</a>(
    &amp;self,
    waitfds: &amp;mut [<a class="struct" href="struct.WaitFd.html" title="struct curl::multi::WaitFd">WaitFd</a>],
    timeout: <a class="struct" href="https://doc.rust-lang.org/1.89.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Block until activity is detected or a timeout passes.</p>
<p>The timeout is used in millisecond-precision. Large durations are
clamped at the maximum value curl accepts.</p>
<p>The returned integer will contain the number of internal file
descriptors on which interesting events occurred.</p>
<p>This function is a simpler alternative to using <code>fdset()</code> and <code>select()</code>
and does not suffer from file descriptor limits.</p>
<p>While this method is similar to <a href="struct.Multi.html#method.wait" title="method curl::multi::Multi::wait">Multi::wait</a>, with the following
distinctions:</p>
<ul>
<li>If there are no handles added to the multi, poll will honor the
provided timeout, while <a href="struct.Multi.html#method.wait" title="method curl::multi::Multi::wait">Multi::wait</a> returns immediately.</li>
<li>If poll has blocked due to there being no activity on the handles in
the Multi, it can be woken up from any thread and at any time before
the timeout expires.</li>
</ul>
<p>Requires libcurl 7.66.0 or later.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>curl::multi::Multi;
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span>m = Multi::new();

<span class="comment">// Add some Easy handles...

</span><span class="kw">while </span>m.perform().unwrap() &gt; <span class="number">0 </span>{
    m.poll(<span class="kw-2">&amp;mut </span>[], Duration::from_secs(<span class="number">1</span>)).unwrap();
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.waker" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#689-691">Source</a><h4 class="code-header">pub fn <a href="#method.waker" class="fn">waker</a>(&amp;self) -&gt; <a class="struct" href="struct.MultiWaker.html" title="struct curl::multi::MultiWaker">MultiWaker</a></h4></section></summary><div class="docblock"><p>Returns a new <a href="struct.MultiWaker.html" title="struct curl::multi::MultiWaker">MultiWaker</a> that can be used to wake up a thread that’s
currently blocked in <a href="struct.Multi.html#method.poll" title="method curl::multi::Multi::poll">Multi::poll</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.perform" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#733-739">Source</a><h4 class="code-header">pub fn <a href="#method.perform" class="fn">perform</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Reads/writes available data from each easy handle.</p>
<p>This function handles transfers on all the added handles that need
attention in an non-blocking fashion.</p>
<p>When an application has found out there’s data available for this handle
or a timeout has elapsed, the application should call this function to
read/write whatever there is to read or write right now etc.  This
method returns as soon as the reads/writes are done. This function does
not require that there actually is any data available for reading or
that data can be written, it can be called just in case. It will return
the number of handles that still transfer data.</p>
<p>If the amount of running handles is changed from the previous call (or
is less than the amount of easy handles you’ve added to the multi
handle), you know that there is one or more transfers less “running”.
You can then call <code>info</code> to get information about each individual
completed transfer, and that returned info includes <code>Error</code> and more.
If an added handle fails very quickly, it may never be counted as a
running handle.</p>
<p>When running_handles is set to zero (0) on the return of this function,
there is no longer any transfers in progress.</p>
<h5 id="return"><a class="doc-anchor" href="#return">§</a>Return</h5>
<p>Before libcurl version 7.20.0: If you receive <code>is_call_perform</code>, this
basically means that you should call <code>perform</code> again, before you select
on more actions. You don’t have to do it immediately, but the return
code means that libcurl may have more data available to return or that
there may be more data to send off before it is “satisfied”. Do note
that <code>perform</code> will return <code>is_call_perform</code> only when it wants to be
called again immediately. When things are fine and there is nothing
immediate it wants done, it’ll return <code>Ok</code> and you need to wait for
“action” and then call this function again.</p>
<p>This function only returns errors etc regarding the whole multi stack.
Problems still might have occurred on individual transfers even when
this function returns <code>Ok</code>. Use <code>info</code> to figure out how individual
transfers did.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fdset2" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#772-796">Source</a><h4 class="code-header">pub fn <a href="#method.fdset2" class="fn">fdset2</a>(
    &amp;self,
    read: <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut fd_set&gt;,
    write: <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut fd_set&gt;,
    except: <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut fd_set&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.i32.html">i32</a>&gt;, <a class="struct" href="../struct.MultiError.html" title="struct curl::MultiError">MultiError</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts file descriptor information from a multi handle</p>
<p>This function extracts file descriptor information from a given
handle, and libcurl returns its <code>fd_set</code> sets. The application can use
these to <code>select()</code> on, but be sure to <code>FD_ZERO</code> them before calling
this function as curl_multi_fdset only adds its own descriptors, it
doesn’t zero or otherwise remove any others. The curl_multi_perform
function should be called as soon as one of them is ready to be read
from or written to.</p>
<p>If no file descriptors are set by libcurl, this function will return
<code>Ok(None)</code>. Otherwise <code>Ok(Some(n))</code> will be returned where <code>n</code> the
highest descriptor number libcurl set. When <code>Ok(None)</code> is returned it
is because libcurl currently does something that isn’t possible for
your application to monitor with a socket and unfortunately you can
then not know exactly when the current action is completed using
<code>select()</code>. You then need to wait a while before you proceed and call
<code>perform</code> anyway.</p>
<p>When doing <code>select()</code>, you should use <code>get_timeout</code> to figure out
how long to wait for action. Call <code>perform</code> even if no activity has
been seen on the <code>fd_set</code>s after the timeout expires as otherwise
internal retries and timeouts may not work as you’d think and want.</p>
<p>If one of the sockets used by libcurl happens to be larger than what
can be set in an <code>fd_set</code>, which on POSIX systems means that the file
descriptor is larger than <code>FD_SETSIZE</code>, then libcurl will try to not
set it. Setting a too large file descriptor in an <code>fd_set</code> implies an out
of bounds write which can cause crashes, or worse. The effect of NOT
storing it will possibly save you from the crash, but will make your
program NOT wait for sockets it should wait for…</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.raw" class="method"><a class="src rightside" href="../../src/curl/multi.rs.html#813-815">Source</a><h4 class="code-header">pub fn <a href="#method.raw" class="fn">raw</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.pointer.html">*mut </a><a class="enum" href="https://docs.rs/curl-sys/0.4/curl_sys/enum.CURLM.html" title="enum curl_sys::CURLM">CURLM</a></h4></section></summary><div class="docblock"><p>Get a pointer to the raw underlying CURLM handle.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Multi" class="impl"><a class="src rightside" href="../../src/curl/multi.rs.html#857-861">Source</a><a href="#impl-Debug-for-Multi" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/curl/multi.rs.html#858-860">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.89.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.89.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Multi" class="impl"><a href="#impl-Freeze-for-Multi" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section><section id="impl-RefUnwindSafe-for-Multi" class="impl"><a href="#impl-RefUnwindSafe-for-Multi" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section><section id="impl-Send-for-Multi" class="impl"><a href="#impl-Send-for-Multi" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section><section id="impl-Sync-for-Multi" class="impl"><a href="#impl-Sync-for-Multi" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section><section id="impl-Unpin-for-Multi" class="impl"><a href="#impl-Unpin-for-Multi" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section><section id="impl-UnwindSafe-for-Multi" class="impl"><a href="#impl-UnwindSafe-for-Multi" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Multi.html" title="struct curl::multi::Multi">Multi</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.89.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.89.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.89.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#774">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#777">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#757-759">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#767">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#813-815">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#817">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#820">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#798-800">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#802">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.89.0/src/core/convert/mod.rs.html#805">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>